From ff8eddbaa89ea7cd1078ac6602139e386849ba15 Mon Sep 17 00:00:00 2001
From: Mark Vainomaa <mikroskeem@mikroskeem.eu>
Date: Sat, 12 Jun 2021 21:43:00 +0300
Subject: [PATCH 3/3] Clean up shmget flags and alignment checking

---
 src/hotspot/os/linux/os_linux.cpp | 30 ++++++++++++++++++------------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
index be745293c4c..08645ebfe34 100644
--- a/src/hotspot/os/linux/os_linux.cpp
+++ b/src/hotspot/os/linux/os_linux.cpp
@@ -110,6 +110,7 @@
 # include <inttypes.h>
 # include <sys/ioctl.h>
 # include <linux/elf-em.h>
+# include <linux/mman.h>
 #ifdef __GLIBC__
 # include <malloc.h>
 #endif
@@ -3882,6 +3883,22 @@ static char* shmat_large_pages(int shmid, size_t bytes, size_t alignment, char*
   }
 }
 
+static int apply_shm_huge_mask(size_t bytes) {
+  // Determine shift
+  int shift = 0;
+  size_t b = bytes;
+  while (b >>= 1) {
+	  shift++;
+  }
+
+  // XXX: gross, but does the trick for 2M and 1G large page support for now.
+  if (shift == 21 || shift == 30 && is_aligned(bytes, (1 << shift))) {
+    return (shift & MAP_HUGE_MASK) << MAP_HUGE_SHIFT;
+  }
+
+  return 0;
+}
+
 char* os::Linux::reserve_memory_special_shm(size_t bytes, size_t alignment,
                                             char* req_addr, bool exec) {
   // "exec" is passed in but not used.  Creating the shared image for
@@ -3896,18 +3913,7 @@ char* os::Linux::reserve_memory_special_shm(size_t bytes, size_t alignment,
 
   // Create a large shared memory region to attach to based on size.
   // Currently, size is the total size of the heap.
-  int flags = SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W;
-  #define _1G_ALIGN 1073741824
-  if (is_aligned(bytes, _1G_ALIGN)) {
-    #define _MAP_HUGE_MASK 0x3f
-    #define _MAP_HUGE_SHIFT 26
-    int shift = 30;
-    flags |= (shift & _MAP_HUGE_MASK) << _MAP_HUGE_SHIFT;
-    #undef _MAP_HUGE_MASK
-    #undef _MAP_HUGE_SHIFT
-  }
-  #undef _1G_ALIGN
-  int shmid = shmget(IPC_PRIVATE, bytes, flags);
+  int shmid = shmget(IPC_PRIVATE, bytes, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W|apply_shm_huge_mask(bytes));
   if (shmid == -1) {
     // Possible reasons for shmget failure:
     // 1. shmmax is too small for Java heap.
-- 
2.31.1

